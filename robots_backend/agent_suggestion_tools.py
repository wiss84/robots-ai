from langchain_core.tools import tool
from pydantic import BaseModel, Field
import httpx
import os
import difflib
import re
import ast
import subprocess
import json

API_BASE_URL = os.getenv("API_BASE_URL", "http://localhost:8000")

# --- 1. Code Analysis Tool ---
class CodeAnalysisInput(BaseModel):
    file_path: str = Field(..., description="Path to the file to analyze (relative to project root)")
    context: str = Field(None, description="Additional context about the task or project")

@tool("code_analysis", args_schema=CodeAnalysisInput, return_direct=True)
def code_analysis_tool(file_path: str, context: str = None) -> dict:
    """Analyze code patterns and detect potential improvements."""
    # Read the file content
    params = {"path": file_path}
    with httpx.Client() as client:
        resp = client.get(f"{API_BASE_URL}/project/files/read", params=params)
        resp.raise_for_status()
        file_data = resp.json()
    
    content = "".join(file_data.get("lines", []))
    
    # Basic analysis (to be enhanced with more sophisticated logic)
    analysis = {
        "file_path": file_path,
        "line_count": len(file_data.get("lines", [])),
        "patterns": {
            "todo_comments": len(re.findall(r'\bTODO\b', content)),
            "fixme_comments": len(re.findall(r'\bFIXME\b', content)),
            "empty_catch_blocks": len(re.findall(r'catch\s*\([^)]*\)\s*\{\s*\}', content)),
            "console_logs": len(re.findall(r'console\.log', content)),
            "magic_numbers": len(re.findall(r'\b\d{3,}\b', content)),
        },
        "context": context
    }
    
    return analysis

# --- 2. Suggestion Generation Tool ---
class SuggestionGenerationInput(BaseModel):
    file_path: str = Field(..., description="Path to the file to generate suggestions for")
    analysis: dict = Field(None, description="Analysis results from code_analysis_tool")
    suggestion_type: str = Field("improvement", description="Type of suggestion: 'improvement', 'refactor', 'bug_fix', 'feature'")

@tool("suggestion_generation", args_schema=SuggestionGenerationInput, return_direct=True)
def suggestion_generation_tool(file_path: str, analysis: dict = None, suggestion_type: str = "improvement") -> dict:
    """Generate contextual code suggestions based on analysis."""
    # Read the file content if analysis doesn't contain it
    if not analysis or "content" not in analysis:
        params = {"path": file_path}
        with httpx.Client() as client:
            resp = client.get(f"{API_BASE_URL}/project/files/read", params=params)
            resp.raise_for_status()
            file_data = resp.json()
        content = "".join(file_data.get("lines", []))
    else:
        content = analysis.get("content")
    
    # This is a placeholder for the actual suggestion generation logic
    # In a real implementation, this would use the LLM to generate suggestions
    suggestion = {
        "file_path": file_path,
        "original_content": content,
        "suggestion_type": suggestion_type,
        "description": f"Suggested {suggestion_type} for {file_path}",
        # Placeholder for proposed content - in real implementation, this would be generated by the LLM
        "proposed_content": content
    }
    
    return suggestion

# --- 3. Diff Generation Tool ---
class DiffGenerationInput(BaseModel):
    original_content: str = Field(..., description="Original content of the file")
    proposed_content: str = Field(..., description="Proposed content with changes")

@tool("diff_generation", args_schema=DiffGenerationInput, return_direct=True)
def diff_generation_tool(original_content: str, proposed_content: str) -> dict:
    """Generate a clean diff between original and proposed content."""
    # Split content into lines
    original_lines = original_content.splitlines()
    proposed_lines = proposed_content.splitlines()
    
    # Generate unified diff
    diff = difflib.unified_diff(
        original_lines,
        proposed_lines,
        lineterm='',
        n=3  # Context lines
    )
    
    # Convert diff iterator to string
    diff_text = '\n'.join(diff)
    
    return {
        "diff": diff_text,
        "has_changes": original_content != proposed_content
    }

# --- 4. Code Validation Tool ---
class CodeValidationInput(BaseModel):
    file_path: str = Field(..., description="Path to the file to validate")
    content: str = Field(..., description="Content to validate")

@tool("code_validation", args_schema=CodeValidationInput, return_direct=True)
def code_validation_tool(file_path: str, content: str) -> dict:
    """Perform comprehensive syntax and semantic validation for code files using AST analysis."""
    try:
        # Get file extension
        file_ext = os.path.splitext(file_path)[1].lower()
        
        validation_result = {
            "file_path": file_path,
            "is_valid": True,
            "errors": [],
            "warnings": [],
            "file_type": file_ext,
            "metrics": {
                "lines_of_code": len([line for line in content.split('\n') if line.strip()]),
                "complexity_score": 0,
                "maintainability_issues": []
            }
        }
        
        if file_ext == '.py':
            # Enhanced Python validation with AST analysis
            try:
                # Parse AST for deeper analysis
                tree = ast.parse(content, filename=file_path)
                
                # Basic syntax validation
                compile(content, file_path, 'exec')
                
                # AST-based analysis
                validator = PythonASTValidator()
                ast_issues = validator.validate(tree, content)
                validation_result["warnings"].extend(ast_issues["warnings"])
                validation_result["metrics"]["complexity_score"] = ast_issues["complexity"]
                validation_result["metrics"]["maintainability_issues"] = ast_issues["maintainability"]
                
            except SyntaxError as e:
                validation_result["is_valid"] = False
                validation_result["errors"].append({
                    "line": e.lineno or 0,
                    "column": e.offset or 0,
                    "message": str(e.msg) if hasattr(e, 'msg') else str(e),
                    "type": "SyntaxError",
                    "severity": "error"
                })
            except Exception as e:
                validation_result["errors"].append({
                    "line": 0,
                    "message": f"AST parsing error: {str(e)}",
                    "type": "ParseError",
                    "severity": "error"
                })
        
        elif file_ext in ['.js', '.ts', '.jsx', '.tsx']:
            # Enhanced JavaScript/TypeScript validation
            js_result = validate_javascript_content(content, file_ext)
            validation_result["is_valid"] = js_result["valid"]
            validation_result["errors"].extend(js_result["errors"])
            validation_result["warnings"].extend(js_result["warnings"])
            validation_result["metrics"].update(js_result["metrics"])
        
        elif file_ext in ['.html', '.htm']:
            # Basic HTML validation
            html_result = validate_html_content(content)
            validation_result.update(html_result)
        
        elif file_ext in ['.css', '.scss', '.sass']:
            # Basic CSS validation
            css_result = validate_css_content(content)
            validation_result.update(css_result)
        
        else:
            validation_result["warnings"].append({
                "message": f"Validation not implemented for {file_ext} files",
                "type": "UnsupportedFileType",
                "severity": "info"
            })
        
        return validation_result
        
    except Exception as e:
        return {
            "file_path": file_path,
            "is_valid": False,
            "errors": [{"message": f"Validation error: {str(e)}", "type": "ValidationError", "severity": "error"}],
            "warnings": [],
            "file_type": "unknown",
            "metrics": {"lines_of_code": 0, "complexity_score": 0, "maintainability_issues": []}
        }


class PythonASTValidator(ast.NodeVisitor):
    """AST-based Python code validator for advanced analysis."""
    
    def __init__(self):
        self.warnings = []
        self.complexity = 0
        self.maintainability_issues = []
        self.current_line = 0
    
    def validate(self, tree, content):
        """Perform AST-based validation."""
        self.content_lines = content.split('\n')
        self.visit(tree)
        
        return {
            "warnings": self.warnings,
            "complexity": self.complexity,
            "maintainability": self.maintainability_issues
        }
    
    def visit_FunctionDef(self, node):
        """Analyze function definitions."""
        # Check function complexity
        if len(node.body) > 20:
            self.maintainability_issues.append({
                "line": node.lineno,
                "message": f"Function '{node.name}' is too long ({len(node.body)} statements)",
                "type": "ComplexityWarning"
            })
        
        # Check for missing docstrings
        if not ast.get_docstring(node):
            self.warnings.append({
                "line": node.lineno,
                "message": f"Function '{node.name}' missing docstring",
                "type": "DocumentationWarning",
                "severity": "warning"
            })
        
        self.complexity += 1
        self.generic_visit(node)
    
    def visit_If(self, node):
        """Analyze if statements for complexity."""
        self.complexity += 1
        self.generic_visit(node)
    
    def visit_For(self, node):
        """Analyze for loops."""
        self.complexity += 2
        self.generic_visit(node)
    
    def visit_While(self, node):
        """Analyze while loops."""
        self.complexity += 2
        self.generic_visit(node)


def validate_javascript_content(content, file_ext):
    """Validate JavaScript/TypeScript content using Node.js tools if available."""
    import tempfile
    
    result = {
        "valid": True,
        "errors": [],
        "warnings": [],
        "metrics": {
            "lines_of_code": len([line for line in content.split('\n') if line.strip()]),
            "complexity_score": 0,
            "maintainability_issues": []
        }
    }
    
    try:
        # Basic syntax checks
        basic_js_validation = perform_basic_js_validation(content)
        result["warnings"].extend(basic_js_validation)
        
        # Try to use Node.js for advanced validation if available
        try:
            with tempfile.NamedTemporaryFile(mode='w', suffix=f'.{file_ext}', delete=False) as tmp_file:
                tmp_file.write(content)
                tmp_file_path = tmp_file.name
            
            # Try ESLint if available
            try:
                eslint_result = subprocess.run(
                    ['npx', 'eslint', '--format', 'json', tmp_file_path],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                
                if eslint_result.returncode == 0 or eslint_result.stdout:
                    eslint_data = json.loads(eslint_result.stdout)
                    if eslint_data and len(eslint_data) > 0:
                        for message in eslint_data[0].get('messages', []):
                            severity = 'error' if message['severity'] == 2 else 'warning'
                            issue = {
                                "line": message.get('line', 0),
                                "column": message.get('column', 0),
                                "message": message.get('message', ''),
                                "type": message.get('ruleId', 'ESLintRule'),
                                "severity": severity
                            }
                            
                            if severity == 'error':
                                result["errors"].append(issue)
                                result["valid"] = False
                            else:
                                result["warnings"].append(issue)
                                
            except (subprocess.TimeoutExpired, subprocess.CalledProcessError, json.JSONDecodeError):
                # ESLint not available or failed, use basic validation
                pass
            
            # Clean up temp file
            os.unlink(tmp_file_path)
            
        except Exception:
            # Node.js tools not available, use basic validation only
            pass
            
    except Exception as e:
        result["warnings"].append({
            "message": f"JavaScript validation error: {str(e)}",
            "type": "ValidationError",
            "severity": "warning"
        })
    
    return result


def perform_basic_js_validation(content):
    """Perform basic JavaScript validation using regex patterns."""
    warnings = []
    lines = content.split('\n')
    
    for i, line in enumerate(lines, 1):
        line = line.strip()
        
        # Check for common issues
        if '==' in line and '===' not in line:
            warnings.append({
                "line": i,
                "message": "Consider using '===' instead of '==' for strict equality",
                "type": "StyleWarning",
                "severity": "warning"
            })
        
        if 'var ' in line:
            warnings.append({
                "line": i,
                "message": "Consider using 'let' or 'const' instead of 'var'",
                "type": "ModernJSWarning",
                "severity": "info"
            })
        
        # Check for missing semicolons (basic check)
        if line and not line.endswith((';', '{', '}', ':', ',')) and not line.startswith(('//', '/*', '*')):
            if any(keyword in line for keyword in ['if', 'for', 'while', 'function', 'class']):
                continue
            warnings.append({
                "line": i,
                "message": "Missing semicolon",
                "type": "SyntaxWarning",
                "severity": "warning"
            })
    
    return warnings


def validate_html_content(content):
    """Basic HTML validation."""
    import re
    
    result = {
        "is_valid": True,
        "errors": [],
        "warnings": []
    }
    
    # Check for basic HTML structure
    if not re.search(r'<html[^>]*>', content, re.IGNORECASE):
        result["warnings"].append({
            "message": "Missing <html> tag",
            "type": "StructureWarning",
            "severity": "warning"
        })
    
    # Check for unclosed tags (basic)
    open_tags = re.findall(r'<([a-zA-Z][a-zA-Z0-9]*)[^>]*>', content)
    close_tags = re.findall(r'</([a-zA-Z][a-zA-Z0-9]*)>', content)
    
    self_closing = {'img', 'br', 'hr', 'input', 'meta', 'link'}
    open_tags = [tag for tag in open_tags if tag.lower() not in self_closing]
    
    for tag in open_tags:
        if tag not in close_tags:
            result["warnings"].append({
                "message": f"Potentially unclosed tag: <{tag}>",
                "type": "StructureWarning",
                "severity": "warning"
            })
    
    return result


def validate_css_content(content):
    """Basic CSS validation."""
    result = {
        "is_valid": True,
        "errors": [],
        "warnings": []
    }
    
    lines = content.split('\n')
    brace_count = 0
    
    for i, line in enumerate(lines, 1):
        line = line.strip()
        
        # Count braces
        brace_count += line.count('{') - line.count('}')
        
        # Check for missing semicolons in property declarations
        if ':' in line and not line.endswith((';', '{', '}')) and not line.startswith(('/*', '//', '@')):
            result["warnings"].append({
                "line": i,
                "message": "Missing semicolon in CSS property",
                "type": "SyntaxWarning",
                "severity": "warning"
            })
    
    # Check for unmatched braces
    if brace_count != 0:
        result["errors"].append({
            "message": f"Unmatched braces in CSS (difference: {brace_count})",
            "type": "SyntaxError",
            "severity": "error"
        })
        result["is_valid"] = False
    
    return result
